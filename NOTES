  
For some reason this causes a space leak:

  let msgs = (map snd) <$> unfoldWhileM (toBool.fst) (getMessage hwnd (Nothing, Nothing))
  msgs >>= sequence_.(map dispatchMessage)


hSetBuffering stdout NoBuffering

Vulkan extensions rely on external symbols to be defined. My solution to the problem is to to use "type" aliases for such types and
always defined them in terms of Foreign.C.Types and Foreign.Ptr types, which is inevitable since those are always native types. Structs
are never passed by value in the APIs, only by pointer, and Haskell doesn't support by-value passing anyway.

MonadIO class generalizes IO

Build Requirements:

- vulkan.lib
- glslangValidator.exe

Solution #1: Define LUNARG_SDK variable to find it and it's tools
Problem: I can't read environment variables from cabal

Solution #2: 
  Use extra-lib-dirs to specify path to Vulkan SDK, this seems to the normal practise.
  The only requirement is to install SDK into default location.

  if os(mingw32)
    extra-lib-dirs: C:\VulkanSDK\1.0.8.0\Bin32
    extra-libraries:     vulkan-1
  else
    extra-libraries:     vulkan
  
  System.Info.os always reports mingw32, and not windows.
  



















mkWindow :: ... -> IO(Window)
setCaption :: String -> IO()
setBorderWidth
setCaptionHeight :: Int -> IO()
setCaptionHitTest :: Window -> ((Int,Int) -> Bool)
setIcon :: String -> IO()
setTitle :: Window -> String -> IO()
pumpMessages :: MessagePumpMode -> IO()
data MessagePumpMode =  Blocking | NonBlocking



Some controls have special roles: minimize, maximize, caption. It's useful on Windows, 


Key Press

data Key = A | B | C

data Event = 
  KeyPress Key
  KeyRelease Key
  MouseButtonDown Button
  MouseButtonUp Button
  MouseMove Point
  Exit

apUpdate :: Application -> Event -> Application -- analog of recieve


uiUpdate :: Application -> IO [Event]
-- take the hit test function from Application domain
-- in fact all the things you'd expect window to have should be set in here
-- mark things that have changed, so that proper IO action is performed (or just compare)



run :: Application -> [Event] -> IO ()
run ap [] = do
  events <- uiUpdate ap
  run ap events
run _ (Exit:_) = 
  return ()
run ap (e:es) = 
  run (apUpdate ap e) es

--| (assuming all actors speak same language)
type Message = Value 
type Response = Value

data List = Cons Value List | Nil
data Value = VString String | VInteger Integer | VCons 

--| Different actors implement different recieve functions.
--  Recieve may potentially need to send messages to other actors, so it return ActorIO monad(has nothing to do with IO monad, but similar idea)
class Actor a where
  recieve :: a -> Message -> ActorIO(Actor)


--| Maybe actor accepts given pattern, if so it should return that function
-- Pattern is 

recieve :: a -> Message -> ActorIO(Actor)

recieve actor (VString "CapitilizeWindowTitle")= do
  (VString title) <- send (VString "GetWindowTitle") (ActorId 2)
  send (VString "SetWindowTitle")
  return (incrementProcessed actor)




send :: Message -> ActorId -> Computation(Response)


run :: [Actor] -> [Event] -> IO ()


-- react :: (Actor s) => s -> Event -> ActorIO [s] s
-- emit :: 
